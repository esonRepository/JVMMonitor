package com.busi.jvm.agent.scheduler;import java.util.ArrayList;import java.util.List;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.TimeUnit;import org.hyperic.sigar.ProcCpu;import org.hyperic.sigar.ProcMem;import org.hyperic.sigar.ProcState;import com.alibaba.fastjson.JSON;import com.busi.jvm.agent.MessageAgent;import com.busi.jvm.agent.dto.ProcessDto;import com.busi.jvm.agent.dto.TransactionDto;import com.busi.jvm.agent.dto.builder.ProcessDtoBuilder;import com.busi.jvm.agent.sigar.SigarUtil;import com.busi.jvm.agent.tools.HttpClientTools;/** * Created by eson on 2017/12/5. */public class StatisticsScheduler {	private final static ScheduledExecutorService	processScheduleExecutor		= Executors.newScheduledThreadPool(1);	private final static ScheduledExecutorService	transactionScheduleExecutor	= Executors.newScheduledThreadPool(1);	public static void startStatistics() {		startTransactionStatistics();		startProcessStatistics();	}	private static void startProcessStatistics() {		processScheduleExecutor.scheduleAtFixedRate(new Runnable() {			@Override			public void run() {				try {					MessageAgent messageAgent = MessageAgent.getInstance();					ProcCpu pCpu = new ProcCpu();					pCpu.gather(SigarUtil.getSigar(), SigarUtil.getProcessId());					double cpuPercent = pCpu.getPercent();					ProcMem procMem = SigarUtil.getSigar().getProcMem(SigarUtil.getProcessId());					long size = procMem.getSize();					long resident = procMem.getResident();					long share = procMem.getShare();					long free = size - resident - share;					long used = resident + share;					float freeMem = ((float) free) / (1024 * 1024);					float usedMem = ((float) used) / (1024 * 1024);					ProcState prs = SigarUtil.getSigar().getProcState(SigarUtil.getProcessId());					long threadCount = prs.getThreads();					ProcessDto processDto = ProcessDtoBuilder.buildProcess((float) cpuPercent, freeMem, usedMem,							threadCount);					String processJson = JSON.toJSONString(processDto);					HttpClientTools.doPost(messageAgent.getKafakProcessIndexProducerUrl(), processJson);				} catch (Exception e) {					e.printStackTrace();				}			}		}, 60, 60, TimeUnit.SECONDS);	}	private static void startTransactionStatistics() {		transactionScheduleExecutor.scheduleAtFixedRate(new Runnable() {			@Override			public void run() {				try {					MessageAgent messageAgent = MessageAgent.getInstance();					List<TransactionDto> transactions = new ArrayList<>();					int i = 0;					while (i < 10000) {						TransactionDto transaction = messageAgent.getTransactionQueue().poll();						if (transaction == null) {							break;						}						i++;						transactions.add(transaction);					}					if (!transactions.isEmpty()) {						if (transactions.size() > 500) {							int page = (int) Math.ceil((double) transactions.size() / 500);							for (int pageIndex = 1; pageIndex <= page; pageIndex++) {								int startIndex = (pageIndex - 1) * 500;								int endIndex = pageIndex * 500 - 1;								if (endIndex >= transactions.size()) {									endIndex = transactions.size() - 1;								}								List<TransactionDto> subContents = transactions.subList(startIndex, endIndex + 1);								String transactionJson = JSON.toJSONString(subContents);								HttpClientTools.doPost(messageAgent.getKafkaTransactionIndexProducerUrl(),										transactionJson);							}						} else {							String transactionJson = JSON.toJSONString(transactions);							HttpClientTools.doPost(messageAgent.getKafkaTransactionIndexProducerUrl(), transactionJson);						}					}				} catch (Exception e) {					e.printStackTrace();				}			}		}, 0, 5, TimeUnit.SECONDS);	}}